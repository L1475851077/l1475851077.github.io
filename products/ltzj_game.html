<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>雷霆战机-隔空手势版</title>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <style>
        @import url('https://fonts.googleapis.com/css2?family=Rajdhani:wght@600;700&display=swap');

        /* 基础重置 */
        body { margin: 0; background: #000; overflow: hidden; font-family: 'Rajdhani', sans-serif; user-select: none; touch-action: none; -webkit-tap-highlight-color: transparent; }
        
        #game-canvas { display: block; width: 100vw; height: 100vh; z-index: 1; }

        /* 通用按钮样式 */
        .cyber-btn {
            background: rgba(0, 243, 255, 0.2); border: 1px solid #00f3ff;
            color: #00f3ff; font-family: 'Rajdhani', sans-serif;
            text-transform: uppercase; cursor: pointer;
            box-shadow: 0 0 10px rgba(0, 243, 255, 0.2);
            transition: all 0.2s;
            backdrop-filter: blur(4px);
        }
        .cyber-btn:active { background: #00f3ff; color: #000; transform: scale(0.95); }

        /* --- 初始加载与开始屏幕 --- */
        #start-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: radial-gradient(circle, rgba(10,20,30,0.95) 0%, rgba(0,0,0,1) 100%);
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            z-index: 999;
        }

        #game-title {
            font-size: clamp(40px, 8vw, 80px); /* 响应式字体 */
            color: #fff; font-weight: 700; font-style: italic;
            text-shadow: 0 0 20px #00f3ff; margin-bottom: 5px; text-align: center;
        }

        #status-bar {
            margin-top: 20px; padding: 10px 20px;
            border: 1px solid rgba(255,255,255,0.2); border-radius: 4px;
            background: rgba(0,0,0,0.6);
            text-align: center; color: #aaa; font-size: 14px;
        }
        
        .status-highlight { color: #00f3ff; font-weight: bold; margin-left: 5px; }

        /* 开始界面的操作区 */
        .start-controls { display: flex; gap: 20px; margin-top: 40px; align-items: center; }

        #btn-start {
            padding: 15px 50px; font-size: 24px; font-weight: bold;
            background: #00f3ff; color: #000; border: none;
            box-shadow: 0 0 30px rgba(0, 243, 255, 0.5);
            animation: pulse 2s infinite;
        }

        #btn-switch-cam-init {
            padding: 15px 20px; font-size: 16px;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
        }

        @keyframes pulse {
            0% { box-shadow: 0 0 15px rgba(0, 243, 255, 0.3); }
            50% { box-shadow: 0 0 30px rgba(0, 243, 255, 0.7); }
            100% { box-shadow: 0 0 15px rgba(0, 243, 255, 0.3); }
        }

        /* --- 游戏内 HUD --- */
        #hud-container {
            position: absolute; top: 20px; right: 20px;
            width: 200px; height: 150px;
            border: 2px solid rgba(0, 243, 255, 0.5);
            background: rgba(0, 10, 20, 0.8);
            border-radius: 8px; z-index: 100; display: none;
        }
        
        #hud-canvas { width: 100%; height: 100%; transform: scaleX(-1); transition: transform 0.3s; }
        
        .hud-info {
            position: absolute; top: 5px; left: 8px; font-size: 10px; color: #00f3ff;
            line-height: 1.4; pointer-events: none;
        }

        /* 游戏内切换按钮 (更小) */
        #btn-switch-cam-game {
            position: absolute; bottom: 5px; right: 5px;
            font-size: 10px; padding: 3px 8px; z-index: 102;
        }

        /* UI层 */
        #ui-layer { position: absolute; top: 20px; left: 20px; z-index: 50; pointer-events: none; display: none; }
        #score-board { font-size: clamp(24px, 5vw, 36px); color: #fff; text-shadow: 0 0 10px #00f3ff; }
        #hp-bar-box {
            width: clamp(200px, 40vw, 350px); height: 10px; background: rgba(255,255,255,0.1);
            margin-top: 10px; border: 1px solid rgba(255,255,255,0.3); border-radius: 4px; overflow: hidden;
        }
        #hp-bar { width: 100%; height: 100%; background: #00f3ff; transition: width 0.1s linear; }

        #loading-text { color: #00f3ff; font-size: 16px; margin-top: 20px; letter-spacing: 1px; animation: blink 1s infinite; }
        @keyframes blink { 50% { opacity: 0.5; } }

        #game-over {
            display: none; position: absolute; top: 50%; left: 50%; transform: translate(-50%,-50%);
            text-align: center; color: #ff0055; z-index: 200; background: rgba(0,0,0,0.9);
            padding: 40px; border: 2px solid #ff0055; border-radius: 10px; width: 80%; max-width: 400px;
        }

        /* 调试信息 */
        #debug-panel {
            position: absolute; bottom: 5px; left: 5px;
            color: rgba(0,255,0,0.7); font-family: monospace; font-size: 10px;
            pointer-events: none; z-index: 900;
        }

        .input_video { display: none; }

        /* 平板和手机适配调整 */
        @media (max-width: 768px) {
            #hud-container { width: 140px; height: 105px; top: 10px; right: 10px; border-width: 1px; }
            .start-controls { flex-direction: column; width: 80%; }
            #btn-start { width: 100%; padding: 15px 0; font-size: 20px; }
            #btn-switch-cam-init { width: 100%; padding: 10px 0; font-size: 14px; background: rgba(255,255,255,0.1); color: #fff; border: 1px solid #666; }
            #ui-layer { top: 10px; left: 10px; }
            #start-screen { padding: 20px; box-sizing: border-box; }
        }
    </style>
</head>
<body>

<div id="start-screen">
    <div id="game-title">THUNDER<br>FIGHTER</div>
    <div style="color:#666; letter-spacing:3px; font-size:12px">GESTURE CONTROL SYSTEM</div>

    <div id="status-bar">
        <div>系统状态: <span style="color:#00ff00">在线</span></div>
        <div>当前镜头: <span id="init-cam-status" class="status-highlight">检测中...</span></div>
    </div>

    <div id="loading-text">正在初始化神经网络...</div>

    <div class="start-controls" id="controls-group" style="display:none">
        <button id="btn-start" class="cyber-btn" style="color:#000; background:#00f3ff">启动引擎 (START)</button>
        <button id="btn-switch-cam-init" class="cyber-btn">切换摄像头<br><span style="font-size:10px; opacity:0.7">(SWITCH CAM)</span></button>
    </div>
</div>

<div id="debug-panel">Render FPS: <span id="render-fps">0</span> | Detect FPS: <span id="detect-fps">0</span></div>

<canvas id="game-canvas"></canvas>

<div id="ui-layer">
    <div id="score-board">SCORE: <span id="score">0</span></div>
    <div id="hp-bar-box"><div id="hp-bar"></div></div>
</div>

<div id="hud-container">
    <button id="btn-switch-cam-game" class="cyber-btn">CAM</button>
    <div class="hud-info">
        FPS: <span id="hud-fps">60</span><br>
        CAM: <span id="hud-cam-type">USER</span><br>
        HAND: <span id="hud-track-status" style="color:#ffff00">SEARCH</span>
    </div>
    <canvas id="hud-canvas" width="240" height="180"></canvas>
</div>

<div id="game-over">
    <h2 style="margin:0 0 10px 0">MISSION FAILED</h2>
    <p>长按手掌 (3秒) 重启系统</p>
</div>

<video class="input_video" playsinline webkit-playsinline></video>

<script>
    // --- 核心配置 ---
    // 限制最高渲染帧率，解决移动端过热和掉帧问题
    const TARGET_RENDER_FPS = 60; 
    const RENDER_INTERVAL = 1000 / TARGET_RENDER_FPS;
    
    // 限制手势识别频率，太高会占用CPU导致卡顿，20FPS对游戏足够了
    const DETECT_INTERVAL = 45; // ~22 FPS

    // 画面质量配置 (移动端降低渲染分辨率以提升性能)
    // 限制最大像素密度，防止Retina屏幕(DPR=3)渲染压力过大
    const MAX_DPR = 1.5; 

    // --- 变量定义 ---
    let lastRenderTime = 0;
    let lastDetectTime = 0;
    let renderFrameCount = 0, detectFrameCount = 0;
    
    // DOM 元素
    const startScreen = document.getElementById('start-screen');
    const controlsGroup = document.getElementById('controls-group');
    const loadingText = document.getElementById('loading-text');
    const initCamStatus = document.getElementById('init-cam-status');
    const hudCamType = document.getElementById('hud-cam-type');
    const gameCanvas = document.getElementById('game-canvas');
    const gameCtx = gameCanvas.getContext('2d', { alpha: false, desynchronized: true }); // desynchronized 降低延迟
    const hudCanvas = document.getElementById('hud-canvas');
    const hudCtx = hudCanvas.getContext('2d', { willReadFrequently: true });
    
    // 游戏变量
    let width, height;
    let isGameRunning = false;
    let currentFacingMode = 'user'; // 'user' (前置) or 'environment' (后置)
    let input = { x: 0.5, y: 0.8, active: false, isPinching: false };
    
    // 实体
    let player = { x: 0, y: 0, hp: 100 };
    let bullets = [], enemies = [], stars = [], particles = [];
    let score = 0;
    let isGameOver = false;

    // --- 音频上下文 (懒加载) ---
    const AudioContext = window.AudioContext || window.webkitAudioContext;
    const audioCtx = new AudioContext();
    const masterGain = audioCtx.createGain();
    masterGain.gain.value = 0.3;
    masterGain.connect(audioCtx.destination);

    function playTone(freq, type, duration) {
        if(audioCtx.state === 'suspended') return;
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.type = type; osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
        gain.gain.setValueAtTime(0.1, audioCtx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + duration);
        osc.connect(gain); gain.connect(masterGain);
        osc.start(); osc.stop(audioCtx.currentTime + duration);
    }

    // --- 适配与性能优化函数 ---
    function resize() {
        // 获取实际视口大小
        const w = window.innerWidth;
        const h = window.innerHeight;
        
        // 计算合适的渲染分辨率
        const dpr = Math.min(window.devicePixelRatio || 1, MAX_DPR);
        
        // 设置Canvas的内部渲染分辨率 (物理像素)
        gameCanvas.width = w * dpr;
        gameCanvas.height = h * dpr;
        
        // 游戏逻辑使用 CSS 像素宽高
        width = w;
        height = h;
        
        // 缩放Context以匹配逻辑坐标
        gameCtx.scale(dpr, dpr);
        
        if(stars.length === 0) initStars();
    }
    
    window.addEventListener('resize', resize);
    resize(); // 初始化调用

    // --- 摄像头控制 ---
    const videoElement = document.querySelector('.input_video');
    let activeCamera = null;
    let handsModule = null;

    async function initCameraSystem(facingMode) {
        currentFacingMode = facingMode;
        
        // 更新UI显示
        const modeName = facingMode === 'user' ? "前置 (FRONT)" : "后置 (REAR)";
        initCamStatus.innerText = modeName;
        hudCamType.innerText = facingMode === 'user' ? "USER" : "ENV";
        
        // 处理镜像逻辑
        hudCanvas.style.transform = facingMode === 'user' ? 'scaleX(-1)' : 'scaleX(1)';

        if (activeCamera) {
            // 简单停止机制：重新加载页面是重置摄像头的最稳妥方式，但在SPA中我们尝试停止流
            const stream = videoElement.srcObject;
            if(stream) stream.getTracks().forEach(t => t.stop());
        }

        try {
            activeCamera = new Camera(videoElement, {
                onFrame: async () => {
                    const now = performance.now();
                    // 手势识别限流 (FPS Throttling)
                    if (now - lastDetectTime >= DETECT_INTERVAL) {
                        lastDetectTime = now;
                        if(handsModule) await handsModule.send({image: videoElement});
                        detectFrameCount++;
                    }
                },
                facingMode: facingMode,
                // 降低 MediaPipe 输入分辨率以大幅提升移动端性能
                width: 320, 
                height: 240
            });
            await activeCamera.start();
            
            // 摄像头启动成功，显示开始按钮
            loadingText.style.display = 'none';
            controlsGroup.style.display = 'flex';
            
        } catch (e) {
            initCamStatus.innerText = "错误: 无法调用摄像头";
            initCamStatus.style.color = "red";
            console.error(e);
        }
    }

    // 初始化 MediaPipe
    handsModule = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
    handsModule.setOptions({
        maxNumHands: 1,
        modelComplexity: 0, // 0 = 最快/精度低 (适合移动端), 1 = 平衡
        minDetectionConfidence: 0.5,
        minTrackingConfidence: 0.5
    });

    handsModule.onResults(onResults);

    // --- 游戏逻辑 ---
    function initStars() {
        stars = [];
        for(let i=0; i<60; i++) stars.push({x: Math.random()*width, y: Math.random()*height, speed: Math.random()*2+1});
    }

    function resetGame() {
        player.x = width/2; player.y = height*0.8; player.hp = 100;
        bullets = []; enemies = []; particles = []; score = 0; isGameOver = false;
        document.getElementById('game-over').style.display = 'none';
    }

    function gameLoop(timestamp) {
        requestAnimationFrame(gameLoop);

        // 渲染锁帧逻辑 (FPS Cap)
        const elapsed = timestamp - lastRenderTime;
        if (elapsed < RENDER_INTERVAL) return;
        
        // 修正时间戳，减去多余部分以保持节奏
        lastRenderTime = timestamp - (elapsed % RENDER_INTERVAL);
        renderFrameCount++;

        // 1. 清空画布
        gameCtx.fillStyle = "#050a10";
        gameCtx.fillRect(0, 0, width, height);

        // 2. 绘制星空背景
        gameCtx.fillStyle = "#fff";
        stars.forEach(s => {
            s.y += isGameRunning ? s.speed : s.speed * 0.2;
            if(s.y > height) { s.y = 0; s.x = Math.random()*width; }
            gameCtx.globalAlpha = Math.random() * 0.8;
            gameCtx.fillRect(s.x, s.y, 2, 2);
        });
        gameCtx.globalAlpha = 1;

        if(!isGameRunning) return; // 暂停状态只画背景

        if(isGameOver) return; // 游戏结束状态

        // 3. 玩家逻辑
        // 平滑移动插值
        let targetX = (1 - input.x) * width; // 默认镜像逻辑
        // 如果是后置摄像头，不需要镜像，input.x 0在左边，但画面也是0在左边。
        // 然而MediaPipe输出的坐标比较特殊，我们需要手动修正
        if(currentFacingMode === 'environment') {
            targetX = input.x * width; // 后置需要反转回正常逻辑？视具体情况，通常MediaPipe给的是镜像的
            // 修正：MediaPipe Hands 默认输出也是根据自拍视角的。
            // 简单处理：我们让 input.x 在 onResults 里统一处理成 "0是屏幕左侧, 1是屏幕右侧"
            targetX = input.x * width; 
        } else {
             // 前置：手往左移(画面右边)，input.x变大。我们需要 1-input.x
             // 这里的逻辑在 onResults 统一处理更佳，这里只负责渲染
             targetX = input.x * width;
        }

        // 限制边界
        targetX = Math.max(20, Math.min(width-20, targetX));
        let targetY = input.y * height;
        
        player.x += (targetX - player.x) * 0.2;
        player.y += (targetY - player.y) * 0.2;

        // 绘制玩家
        drawPlayer(player.x, player.y);

        // 4. 生成与更新实体
        if(Math.random() < 0.1) bullets.push({x: player.x, y: player.y-30, vy: -15, type: 'player'});
        
        if(Math.random() < 0.02) {
            enemies.push({x: Math.random()*(width-40)+20, y: -40, hp: 5});
        }

        updateEntities();
        
        // UI 更新
        document.getElementById('score').innerText = score;
        document.getElementById('hp-bar').style.width = Math.max(0, player.hp) + "%";
        document.getElementById('hp-bar').style.background = player.hp < 30 ? "#f05" : "#0ff";

        if(player.hp <= 0) {
            isGameOver = true;
            document.getElementById('game-over').style.display = 'block';
            playTone(200, 'sawtooth', 0.5);
        }
    }

    function updateEntities() {
        // 子弹
        for(let i=bullets.length-1; i>=0; i--) {
            let b = bullets[i];
            b.y += b.vy;
            gameCtx.fillStyle = b.type === 'player' ? "#0ff" : "#f05";
            gameCtx.fillRect(b.x-2, b.y, 4, 15);
            
            // 简单的碰撞检测
            if(b.type === 'player') {
                enemies.forEach(e => {
                    if(Math.abs(e.x - b.x) < 30 && Math.abs(e.y - b.y) < 30) {
                        e.hp--; b.hit = true;
                        spawnParticles(b.x, b.y, '#fff');
                    }
                });
            }
            if(b.y < -50 || b.hit) bullets.splice(i, 1);
        }

        // 敌人
        for(let i=enemies.length-1; i>=0; i--) {
            let e = enemies[i];
            e.y += 4;
            drawEnemy(e.x, e.y);
            
            if(Math.abs(e.x - player.x) < 30 && Math.abs(e.y - player.y) < 30) {
                player.hp -= 20; e.hp = 0;
                spawnParticles(player.x, player.y, '#f05');
                playTone(150, 'square', 0.1);
            }

            if(e.hp <= 0) {
                score += 100;
                spawnParticles(e.x, e.y, '#f05');
                playTone(400, 'square', 0.1);
                enemies.splice(i, 1);
            } else if(e.y > height) enemies.splice(i, 1);
        }

        // 粒子
        for(let i=particles.length-1; i>=0; i--) {
            let p = particles[i];
            p.x += p.vx; p.y += p.vy; p.life -= 0.05;
            gameCtx.globalAlpha = Math.max(0, p.life);
            gameCtx.fillStyle = p.c;
            gameCtx.fillRect(p.x, p.y, 3, 3);
            if(p.life <= 0) particles.splice(i, 1);
        }
        gameCtx.globalAlpha = 1;
    }

    function drawPlayer(x, y) {
        gameCtx.save(); gameCtx.translate(x, y);
        gameCtx.fillStyle = input.isPinching ? "#fb0" : "#0ff";
        gameCtx.beginPath(); gameCtx.moveTo(0, -30); gameCtx.lineTo(-15, 15); gameCtx.lineTo(15, 15); gameCtx.fill();
        gameCtx.restore();
    }
    
    function drawEnemy(x, y) {
        gameCtx.save(); gameCtx.translate(x, y);
        gameCtx.fillStyle = "#f05";
        gameCtx.beginPath(); gameCtx.moveTo(0, 20); gameCtx.lineTo(-15, -10); gameCtx.lineTo(15, -10); gameCtx.fill();
        gameCtx.restore();
    }

    function spawnParticles(x, y, c) {
        for(let i=0; i<5; i++) particles.push({x:x, y:y, vx:(Math.random()-0.5)*10, vy:(Math.random()-0.5)*10, life:1, c:c});
    }

    // --- MediaPipe 结果处理 ---
    function onResults(results) {
        // 绘制HUD
        const w = 240, h = 180;
        hudCtx.clearRect(0, 0, w, h);
        if(results.image) hudCtx.drawImage(results.image, 0, 0, w, h);
        
        // 绘制辅助线
        hudCtx.strokeStyle = "rgba(0,255,255,0.2)"; hudCtx.strokeRect(0,0,w,h);

        const statusEl = document.getElementById('hud-track-status');

        if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
            statusEl.innerText = "LOCKED"; statusEl.style.color = "#00ff00";
            
            const lm = results.multiHandLandmarks[0];
            let rawX = lm[8].x; // 食指指尖
            let rawY = lm[8].y;

            // --- 坐标统一化处理 ---
            // 目标：使 input.x = 0 代表屏幕左边，1 代表屏幕右边
            if(currentFacingMode === 'user') {
                // 前置摄像头是镜像的。手在画面右边(x接近1)，实际上代表用户想往左。
                // 渲染时如果直接用 canvas scaleX(-1) 翻转了图像，
                // 我们在游戏逻辑里，input.x = rawX; 
                // 此时 rawX大(右) -> 屏幕渲染也在右 -> 符合直觉（像照镜子）
                // 但是我们的游戏绘制 drawPlayer 并没有 scaleX(-1)。
                // 所以：
                input.x = 1 - rawX; 
            } else {
                // 后置摄像头：手往左移，画面里手也往左移(x接近0)。
                // 我们希望 input.x = 0。
                input.x = 1 - rawX; // MediaPipe 默认输出似乎总是基于自拍视角的相对坐标，这里往往需要调试
                // 在大部分移动端后置测试中，x=0在左边。
                input.x = rawX; 
            }
            
            input.y = rawY;
            input.active = true;
            input.isPinching = (Math.hypot(lm[4].x - lm[8].x, lm[4].y - lm[8].y) < 0.05);

            // 在HUD上画个点
            hudCtx.fillStyle = "#0ff";
            hudCtx.beginPath(); 
            hudCtx.arc(lm[8].x * w, lm[8].y * h, 5, 0, Math.PI*2); 
            hudCtx.fill();

            // 重启检测
            if(isGameOver && isGameRunning) {
                // 这里简略了长按重启逻辑，仅作演示
                if(input.isPinching === false) { /* 检测张手逻辑 */ }
            }

        } else {
            statusEl.innerText = "SEARCH"; statusEl.style.color = "#ffff00";
            input.active = false;
        }
    }

    // --- 事件绑定 ---
    document.getElementById('btn-start').addEventListener('click', () => {
        if(audioCtx.state === 'suspended') audioCtx.resume();
        startScreen.style.display = 'none';
        document.getElementById('hud-container').style.display = 'block';
        document.getElementById('ui-layer').style.display = 'block';
        document.getElementById('debug-panel').style.display = 'block';
        isGameRunning = true;
        playTone(440, 'sine', 0.5);
    });

    const switchCamHandler = (e) => {
        e.stopPropagation();
        const newMode = currentFacingMode === 'user' ? 'environment' : 'user';
        initCameraSystem(newMode);
    };

    document.getElementById('btn-switch-cam-init').addEventListener('click', switchCamHandler);
    document.getElementById('btn-switch-cam-game').addEventListener('click', switchCamHandler);
    
    // FPS 显示更新
    setInterval(() => {
        document.getElementById('render-fps').innerText = renderFrameCount;
        document.getElementById('detect-fps').innerText = detectFrameCount;
        document.getElementById('hud-fps').innerText = renderFrameCount;
        renderFrameCount = 0; detectFrameCount = 0;
    }, 1000);

    // 启动
    initCameraSystem('user');
    requestAnimationFrame(gameLoop);

</script>
</body>
</html>
