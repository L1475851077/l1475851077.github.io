<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>雷霆战机-隔空手势版</title>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <style>
        @import url('https://fonts.googleapis.com/css2?family=Rajdhani:wght@600;700&display=swap');

        body { margin: 0; background: #000; overflow: hidden; font-family: 'Rajdhani', sans-serif; user-select: none; touch-action: none; }
        
        #game-canvas { display: block; width: 100vw; height: 100vh; z-index: 1; }

        /* 开始屏幕遮罩 */
        #start-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.85);
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            z-index: 999; backdrop-filter: blur(5px);
        }

        /* 游戏标题 */
        #game-title {
            font-size: 80px; color: #fff; font-weight: 700;
            text-shadow: 0 0 20px #00f3ff, 0 0 40px #00f3ff;
            margin-bottom: 10px; letter-spacing: 5px;
            font-style: italic; text-align: center;
            line-height: 1.1;
        }

        #game-subtitle {
            font-size: 20px; color: #aaa; margin-bottom: 10px; letter-spacing: 2px;
        }

        /* 开始按钮 */
        #btn-start {
            padding: 20px 80px; margin-top: 30px;
            font-size: 32px; font-weight: bold; font-family: 'Rajdhani', sans-serif;
            color: #000; background: #00f3ff;
            border: none; border-radius: 4px;
            cursor: pointer;
            box-shadow: 0 0 30px rgba(0, 243, 255, 0.6);
            transition: all 0.2s;
            text-transform: uppercase;
            letter-spacing: 3px;
            animation: pulse 2s infinite;
        }

        #btn-start:hover {
            background: #fff; box-shadow: 0 0 50px rgba(255, 255, 255, 0.8); transform: scale(1.05);
        }

        #btn-start:active { transform: scale(0.95); }

        @keyframes pulse {
            0% { box-shadow: 0 0 20px rgba(0, 243, 255, 0.4); }
            50% { box-shadow: 0 0 40px rgba(0, 243, 255, 0.8); }
            100% { box-shadow: 0 0 20px rgba(0, 243, 255, 0.4); }
        }

        /* HUD 仪表盘 */
        #hud-container {
            position: absolute; top: 20px; right: 20px;
            width: 240px; height: 180px;
            border: 2px solid #00f3ff;
            background: rgba(0, 10, 20, 0.8);
            border-radius: 8px;
            box-shadow: 0 0 20px rgba(0, 243, 255, 0.3);
            z-index: 100; overflow: hidden;
            display: none; /* 游戏开始前隐藏 */
        }

        /* 切换镜头按钮 */
        #btn-switch-cam {
            position: absolute; bottom: 5px; right: 5px;
            background: rgba(0, 243, 255, 0.2);
            border: 1px solid #00f3ff;
            color: #fff; font-size: 10px; padding: 4px 8px;
            cursor: pointer; z-index: 110; border-radius: 4px;
            font-family: 'Rajdhani', sans-serif;
            pointer-events: auto; /* 确保可点击 */
        }
        #btn-switch-cam:active { background: #00f3ff; color: #000; }

        #hud-canvas { width: 100%; height: 100%; transform: scaleX(-1); transition: transform 0.3s; }

        .hud-overlay-text {
            position: absolute; top: 5px; left: 10px;
            color: #00f3ff; font-size: 12px; 
            text-shadow: 0 0 5px #00f3ff;
            pointer-events: none; z-index: 101; line-height: 1.2;
        }

        /* 性能监控面板 */
        #debug-panel {
            position: absolute; top: 20px; left: 20px;
            color: #00ff00; font-family: monospace; font-size: 12px;
            background: rgba(0,0,0,0.7); padding: 5px; border: 1px solid #00ff00;
            z-index: 600; pointer-events: none; display: none;
        }

        .input_video { display: none; }

        /* UI 层 */
        #ui-layer { position: absolute; top: 60px; left: 20px; z-index: 50; color: #fff; pointer-events: none; display: none; }
        #score-board { font-size: 36px; color: #fff; text-shadow: 0 0 15px #00f3ff; letter-spacing: 2px; }
        #hp-bar-box {
            width: 350px; height: 12px; background: rgba(255,255,255,0.1);
            margin-top: 15px; border: 1px solid rgba(255,255,255,0.3);
            border-radius: 6px; overflow: hidden;
            max-width: 80vw; /* 适配手机宽度 */
        }
        #hp-bar { width: 100%; height: 100%; background: linear-gradient(90deg, #00f3ff, #0066ff); transition: width 0.1s linear; box-shadow: 0 0 15px #00f3ff; }
        #regen-msg { color: #00ff00; font-size: 14px; margin-top: 5px; opacity: 0; transition: opacity 0.3s; text-shadow: 0 0 5px #00ff00; letter-spacing: 1px;}

        #game-over {
            display: none; position: absolute; top: 50%; left: 50%; transform: translate(-50%,-50%);
            text-align: center; color: #ff0055; z-index: 200;
            background: rgba(0,0,0,0.95); padding: 50px; border: 3px solid #ff0055;
            box-shadow: 0 0 50px rgba(255, 0, 85, 0.4); border-radius: 10px;
            width: 80%; max-width: 500px;
        }

        #countdown-layer {
            display: none; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            font-size: 150px; color: #00f3ff; font-weight: bold;
            text-shadow: 0 0 30px #00f3ff, 0 0 60px #fff; z-index: 250;
        }
        
        #loading {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: #00f3ff; font-size: 20px; z-index: 300;
            text-shadow: 0 0 10px #00f3ff; text-align: center;
            background: rgba(0,0,0,0.8); padding: 20px; border-radius: 5px;
            display: block; width: 80%;
        }

        #mode-indicator {
            position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%);
            color: rgba(255,255,255,0.7); font-size: 16px; text-shadow: 0 0 5px #fff; text-align: center;
            display: none; width: 100%;
        }
        .highlight { color: #00f3ff; font-weight: bold; }

        /* 移动端适配 */
        @media (max-width: 768px) {
            #game-title { font-size: 50px; }
            #hud-container { width: 120px; height: 90px; top: 10px; right: 10px; }
            #btn-switch-cam { padding: 2px 5px; font-size: 9px; }
            .hud-overlay-text { font-size: 9px; left: 5px; top: 2px; }
            #ui-layer { top: 10px; left: 10px; }
            #score-board { font-size: 24px; }
            #btn-start { padding: 15px 40px; font-size: 24px; }
        }
    </style>
</head>
<body>

<div id="start-screen" style="display: none;">
    <div id="game-title">雷霆战机<br>移动版</div>
    <div id="game-subtitle">作者：L小炫</div>
    <div id="game-subtitle">请允许摄像头权限</div>
    <div id="game-subtitle" style="font-size: 14px; margin-top:10px; color:#00f3ff">
        <span id="cam-hint">正在启动前置摄像头...</span>
    </div>
    <button id="btn-start">开始游戏</button>
</div>

<div id="debug-panel">
    游戏 FPS: <span id="render-fps">0</span><br>
    追踪 FPS: <span id="detect-fps">0</span>
</div>

<div id="loading">系统初始化中<br>请在摄像头前张开手掌...</div>
<canvas id="game-canvas"></canvas>

<div id="ui-layer">
    <div id="score-board">得分: <span id="score">0</span></div>
    <div id="hp-bar-box"><div id="hp-bar"></div></div>
    <div id="regen-msg">/// 纳米修复中 ///</div>
</div>

<div id="mode-indicator">
    手掌: 移动 | <span class="highlight">捏合手指: 强力射击</span>
</div>

<div id="hud-container">
    <button id="btn-switch-cam">切换镜头</button>
    <div class="hud-overlay-text">
        系统: 在线<br>
        镜头: <span id="camera-type-text">前置</span><br>
        信号: <span id="tracking-status">扫描中</span><br>
        <span id="fire-mode" style="color: #fff">MODE: AUTO</span>
    </div>
    <canvas id="hud-canvas" width="240" height="180"></canvas>
</div>

<div id="game-over">
    <h1 style="font-size: 40px; margin:0 0 20px 0">任务失败</h1>
    <p style="font-size: 16px">长按张开手掌 (3秒) 重启游戏</p>
</div>

<div id="countdown-layer">3</div>
<video class="input_video" playsinline webkit-playsinline></video>

<script>
    // --- 变量定义 ---
    let lastRenderTime = 0; let renderFrameCount = 0;
    let lastDetectTime = 0; let detectFrameCount = 0;
    const renderFpsEl = document.getElementById('render-fps');
    const detectFpsEl = document.getElementById('detect-fps');

    setInterval(() => {
        renderFpsEl.innerText = renderFrameCount;
        detectFpsEl.innerText = detectFrameCount;
        renderFrameCount = 0; detectFrameCount = 0;
    }, 1000);

    const AudioContext = window.AudioContext || window.webkitAudioContext;
    const audioCtx = new AudioContext();
    const masterGain = audioCtx.createGain();
    masterGain.gain.value = 0.4;
    masterGain.connect(audioCtx.destination);

    // 游戏状态控制
    let isGameRunning = false; 
    let hasInitialized = false;

    // --- 音效相关 ---
    let bgmInterval = null;
    let bgmNoteIndex = 0;
    const melody = [523.25, 659.25, 783.99, 1046.50, 783.99, 659.25, 587.33, 739.99, 880.00, 1174.66, 880.00, 739.99, 523.25, 523.25, 0, 0];

    function playBGMNote() {
        if (audioCtx.state === 'suspended') return;
        const freq = melody[bgmNoteIndex];
        bgmNoteIndex = (bgmNoteIndex + 1) % melody.length;
        if (freq > 0) {
            const osc = audioCtx.createOscillator(); const gain = audioCtx.createGain();
            osc.type = 'triangle'; osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
            gain.gain.setValueAtTime(0.08, audioCtx.currentTime); gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.15);
            osc.connect(gain); gain.connect(masterGain); osc.start(); osc.stop(audioCtx.currentTime + 0.2);
        }
    }
    function startBGM() { if (bgmInterval) return; bgmNoteIndex = 0; bgmInterval = setInterval(playBGMNote, 150); }
    function stopBGM() { if (bgmInterval) { clearInterval(bgmInterval); bgmInterval = null; } }

    let chargingOsc1, chargingOsc2, chargingGain;
    function updateChargingSound(progress) {
        if (audioCtx.state === 'suspended') return;
        if (!chargingOsc1) {
            const now = audioCtx.currentTime;
            chargingGain = audioCtx.createGain(); chargingGain.gain.setValueAtTime(0, now); chargingGain.connect(masterGain);
            chargingOsc1 = audioCtx.createOscillator(); chargingOsc1.type = 'sawtooth'; chargingOsc1.connect(chargingGain);
            chargingOsc2 = audioCtx.createOscillator(); chargingOsc2.type = 'square'; chargingOsc2.detune.value = -10; chargingOsc2.connect(chargingGain);
            chargingOsc1.start(now); chargingOsc2.start(now);
        }
        const now = audioCtx.currentTime;
        const baseFreq = 100 + (progress * 800);
        chargingOsc1.frequency.setTargetAtTime(baseFreq, now, 0.1); chargingOsc2.frequency.setTargetAtTime(baseFreq * 0.5, now, 0.1);
        chargingGain.gain.setTargetAtTime(0.05 + (progress * 0.3), now, 0.1);
    }
    function stopChargingSound() {
        if (chargingOsc1) {
            const now = audioCtx.currentTime;
            chargingGain.gain.setTargetAtTime(0, now, 0.1);
            chargingOsc1.stop(now + 0.15); chargingOsc2.stop(now + 0.15);
            chargingOsc1 = null; chargingOsc2 = null; chargingGain = null;
        }
    }

    function playSound(type) {
        if (audioCtx.state === 'suspended') return;
        const now = audioCtx.currentTime;
        const osc = audioCtx.createOscillator(); const gain = audioCtx.createGain();
        osc.connect(gain); gain.connect(masterGain);

        if (type === 'laser') {
            osc.type = 'sawtooth'; osc.frequency.setValueAtTime(800, now); osc.frequency.exponentialRampToValueAtTime(100, now + 0.1);
            gain.gain.setValueAtTime(0.08, now); gain.gain.exponentialRampToValueAtTime(0.001, now + 0.1);
            osc.start(now); osc.stop(now + 0.1);
        } else if (type === 'heavy_laser') {
            osc.type = 'square'; osc.frequency.setValueAtTime(200, now); osc.frequency.linearRampToValueAtTime(50, now + 0.1);
            gain.gain.setValueAtTime(0.15, now); gain.gain.exponentialRampToValueAtTime(0.001, now + 0.1);
            osc.start(now); osc.stop(now + 0.1);
        } else if (type === 'enemy_laser') {
            osc.type = 'square'; osc.frequency.setValueAtTime(300, now); osc.frequency.exponentialRampToValueAtTime(50, now + 0.2);
            gain.gain.setValueAtTime(0.05, now); gain.gain.exponentialRampToValueAtTime(0.001, now + 0.2);
            osc.start(now); osc.stop(now + 0.2);
        } else if (type === 'explosion') {
            osc.type = 'sawtooth'; osc.frequency.setValueAtTime(100, now); osc.frequency.exponentialRampToValueAtTime(10, now + 0.4);
            gain.gain.setValueAtTime(0.2, now); gain.gain.exponentialRampToValueAtTime(0.001, now + 0.4);
            osc.start(now); osc.stop(now + 0.4);
        } else if (type === 'hit') {
            const noise = audioCtx.createOscillator(); noise.type = 'sawtooth'; noise.frequency.value = 50;
            const noiseGain = audioCtx.createGain(); noise.connect(noiseGain); noiseGain.connect(masterGain);
            noise.start(now); noise.stop(now + 0.15);
            noiseGain.gain.setValueAtTime(0.4, now); noiseGain.gain.exponentialRampToValueAtTime(0.001, now + 0.15);
        } else if (type === 'countdown_beep') {
            osc.type = 'sine'; osc.frequency.setValueAtTime(1200, now);
            gain.gain.setValueAtTime(0.15, now); gain.gain.exponentialRampToValueAtTime(0.001, now + 0.1);
            osc.start(now); osc.stop(now + 0.1);
        } else if (type === 'countdown_final') {
            osc.type = 'square'; osc.frequency.setValueAtTime(1200, now); osc.frequency.linearRampToValueAtTime(2000, now + 0.4);
            gain.gain.setValueAtTime(0.2, now); gain.gain.linearRampToValueAtTime(0, now + 0.4);
            osc.start(now); osc.stop(now + 0.4);
        } else if (type === 'start_game') { 
            osc.type = 'square'; osc.frequency.setValueAtTime(440, now); 
            osc.frequency.linearRampToValueAtTime(880, now + 0.1);
            osc.frequency.linearRampToValueAtTime(1760, now + 0.3);
            gain.gain.setValueAtTime(0.3, now); gain.gain.linearRampToValueAtTime(0, now + 0.3);
            osc.start(now); osc.stop(now + 0.3);
        }
    }

    // --- 界面与初始化 ---
    const startScreen = document.getElementById('start-screen');
    const btnStart = document.getElementById('btn-start');
    const loadingEl = document.getElementById('loading');
    const camHintEl = document.getElementById('cam-hint');
    
    // UI 元素
    const uiLayer = document.getElementById('ui-layer');
    const hudContainer = document.getElementById('hud-container');
    const debugPanel = document.getElementById('debug-panel');
    const modeIndicator = document.getElementById('mode-indicator');

    const gameCanvas = document.getElementById('game-canvas');
    const gameCtx = gameCanvas.getContext('2d', { alpha: false, desynchronized: true });
    const hudCanvas = document.getElementById('hud-canvas');
    const hudCtx = hudCanvas.getContext('2d', { willReadFrequently: true });
    const videoElement = document.getElementsByClassName('input_video')[0];
    const hpBar = document.getElementById('hp-bar');
    const scoreEl = document.getElementById('score');
    const regenMsg = document.getElementById('regen-msg');
    const gameOverEl = document.getElementById('game-over');
    const countdownEl = document.getElementById('countdown-layer');
    const fireModeEl = document.getElementById('fire-mode');
    const trackingStatusEl = document.getElementById('tracking-status');
    
    // 摄像头切换 UI
    const btnSwitchCam = document.getElementById('btn-switch-cam');
    const cameraTypeText = document.getElementById('camera-type-text');

    // 点击开始按钮逻辑
    btnStart.addEventListener('click', () => {
        if (audioCtx.state === 'suspended') { audioCtx.resume(); }
        playSound('start_game');
        
        startScreen.style.display = 'none';
        
        uiLayer.style.display = 'block';
        hudContainer.style.display = 'block';
        debugPanel.style.display = 'block';
        modeIndicator.style.display = 'block';
        
        isGameRunning = true;
        startBGM();
    });

    let width, height;
    let input = { x: 0.5, y: 0.8, active: false, isPinching: false };
    let lostTrackingFrames = 0;
    const MAX_LOST_FRAMES = 15; 
    
    let player = { x: 0, y: 0, hp: 100, maxHp: 100 };
    let bullets = [];
    let enemies = [];
    let particles = [];
    let stars = [];
    let score = 0;
    let frameCount = 0;
    let isGameOver = false;
    let lastHitFrame = 0;
    let isRestarting = false; 
    let palmHoldStartTime = 0; 
    let shakeIntensity = 0;

    function resize() {
        width = window.innerWidth;
        height = window.innerHeight;
        gameCanvas.width = width;
        gameCanvas.height = height;
        if(frameCount === 0) resetGameData();
        initStars();
    }
    
    function initStars() {
        stars = [];
        for(let i=0; i<80; i++) stars.push({ x: Math.random()*width, y: Math.random()*height, s: Math.random()*2+1, speed: Math.random()*5+2 });
    }
    
    function resetGameData() {
        player.x = width * 0.5; player.y = height * 0.8; player.hp = 100;
        bullets = []; enemies = []; particles = [];
        score = 0; frameCount = 0; isGameOver = false;
        gameOverEl.style.display = 'none'; countdownEl.style.display = 'none';
        lastHitFrame = 0; isRestarting = false; palmHoldStartTime = 0; shakeIntensity = 0;
        lostTrackingFrames = 0;
        if(isGameRunning) startBGM();
    }

    function startRestartCountdown() {
        if(isRestarting) return;
        isRestarting = true;
        stopChargingSound();
        gameOverEl.style.display = 'none'; countdownEl.style.display = 'block';
        let count = 3;
        countdownEl.innerText = count; playSound('countdown_beep');
        let timer = setInterval(() => {
            count--;
            if(count > 0) { countdownEl.innerText = count; playSound('countdown_beep'); } 
            else { clearInterval(timer); playSound('countdown_final'); resetGameData(); }
        }, 1000);
    }

    window.addEventListener('resize', resize);
    resize();

    // --- 游戏循环 ---
    function gameLoop() {
        renderFrameCount++; 

        if(isGameOver) {
            gameCtx.fillStyle = "rgba(0,0,0,0.1)"; gameCtx.fillRect(0, 0, width, height);
            stopBGM(); requestAnimationFrame(gameLoop); return;
        }
        requestAnimationFrame(gameLoop);
        
        if(isGameRunning) {
            frameCount++;
        }

        // 震动效果
        gameCtx.save();
        if(shakeIntensity > 0) {
            let dx = (Math.random() - 0.5) * shakeIntensity;
            let dy = (Math.random() - 0.5) * shakeIntensity;
            gameCtx.translate(dx, dy);
            shakeIntensity *= 0.9;
            if(shakeIntensity < 0.5) shakeIntensity = 0;
        }

        // 绘制背景
        gameCtx.fillStyle = "#050a10"; gameCtx.fillRect(0, 0, width, height);
        gameCtx.fillStyle = "#fff";
        for(let s of stars) {
            s.y += isGameRunning ? s.speed : s.speed * 0.2;
            if(s.y > height) { s.y = 0; s.x = Math.random()*width; }
            gameCtx.globalAlpha = Math.random(); gameCtx.fillRect(s.x, s.y, s.s, s.s);
        }
        gameCtx.globalAlpha = 1.0;

        if(!isGameRunning) {
            gameCtx.restore();
            return;
        }

        let targetX = (1 - input.x) * width;
        let targetY = input.y * height;
        targetX = Math.max(20, Math.min(width-20, targetX));
        targetY = Math.max(20, Math.min(height-20, targetY));
        player.x += (targetX - player.x) * 0.15;
        player.y += (targetY - player.y) * 0.15;

        spawnEntities();
        updateEntities();
        handleRegeneration();

        drawPlayerPlane(gameCtx, player.x, player.y);
        gameCtx.restore();

        scoreEl.innerText = score;
        hpBar.style.width = Math.max(0, player.hp) + "%";
        hpBar.style.background = player.hp < 30 ? "#ff0055" : "#00f3ff";
        
        if(player.hp <= 0) {
            isGameOver = true; gameOverEl.style.display = 'block'; playSound('hit'); 
        }
    }

    function handleRegeneration() {
        if (frameCount - lastHitFrame > 120 && player.hp < player.maxHp) {
            player.hp += 0.09; regenMsg.style.opacity = 1;
        } else {
            regenMsg.style.opacity = 0;
        }
    }

    function spawnEntities() {
        if(frameCount % 10 === 0) {
            bullets.push({x: player.x, y: player.y-40, isEnemy: false, vx:0, vy:-20, type:'normal'});
            playSound('laser');
        }
        if(input.isPinching && frameCount % 5 === 0) {
             bullets.push({x: player.x - 15, y: player.y-30, isEnemy: false, vx:-2, vy:-22, type:'heavy'});
             bullets.push({x: player.x + 15, y: player.y-30, isEnemy: false, vx:2, vy:-22, type:'heavy'});
             playSound('heavy_laser');
        }
        if(frameCount % 60 === 0) {
            let randomHue = Math.floor(Math.random() * 360);
            enemies.push({ x: Math.random() * (width-100) + 50, y: -50, hp: 6, w: 60, h: 60, lastShot: 0, hue: randomHue });
        }
    }

    function updateEntities() {
        gameCtx.globalCompositeOperation = 'lighter';
        for(let i=particles.length-1; i>=0; i--) {
            let p = particles[i]; p.x += p.vx; p.y += p.vy; p.life -= 0.05;
            gameCtx.fillStyle = p.color; gameCtx.globalAlpha = Math.max(0, p.life);
            gameCtx.fillRect(p.x, p.y, 4, 4);
            if(p.life <= 0) particles.splice(i, 1);
        }
        gameCtx.globalAlpha = 1.0; gameCtx.globalCompositeOperation = 'source-over';

        for(let i=bullets.length-1; i>=0; i--) {
            let b = bullets[i]; b.x += b.vx; b.y += b.vy;
            gameCtx.shadowBlur = 10;
            if(b.isEnemy) {
                let color = `hsl(${b.hue}, 100%, 50%)`;
                gameCtx.shadowColor = color; gameCtx.fillStyle = color;
                gameCtx.beginPath(); gameCtx.arc(b.x, b.y, 5, 0, Math.PI*2); gameCtx.fill();
                if(Math.hypot(b.x - player.x, b.y - player.y) < 30) {
                    player.hp -= 10; lastHitFrame = frameCount; bullets.splice(i, 1); 
                    spawnExplosion(player.x, player.y, "#ff0055", 10); shakeIntensity = 15; playSound('hit'); continue;
                }
            } else {
                gameCtx.shadowColor = b.type === 'heavy' ? "#ffaa00" : "#00f3ff";
                gameCtx.fillStyle = b.type === 'heavy' ? "#ffaa00" : "#00f3ff";
                let w = b.type === 'heavy' ? 6 : 4; gameCtx.fillRect(b.x-w/2, b.y, w, 25);
            }
            gameCtx.shadowBlur = 0;
            if(b.y < -50 || b.y > height+50 || b.x < -50 || b.x > width+50) bullets.splice(i, 1);
        }

        for(let i=enemies.length-1; i>=0; i--) {
            let e = enemies[i]; e.y += 3; e.lastShot++;
            if(e.lastShot > 220) { 
                e.lastShot = 0; let angle = Math.atan2(player.y - e.y, player.x - e.x);
                bullets.push({ x: e.x, y: e.y + 40, isEnemy: true, vx: Math.cos(angle)*1, vy: Math.sin(angle)*1, hue: e.hue });
                playSound('enemy_laser');
            }
            drawEnemyPlane(gameCtx, e.x, e.y, e.hue);
            for(let j=bullets.length-1; j>=0; j--) {
                let b = bullets[j];
                if(!b.isEnemy && Math.abs(b.x - e.x) < 35 && Math.abs(b.y - e.y) < 35) {
                    e.hp -= (b.type === 'heavy' ? 2 : 1); bullets.splice(j, 1);
                    spawnExplosion(b.x, b.y, "#fff", 3);
                    if(e.hp <= 0) {
                        spawnExplosion(e.x, e.y, `hsl(${e.hue}, 100%, 50%)`, 20);
                        shakeIntensity = 5; enemies.splice(i, 1); score += 100; playSound('explosion'); break;
                    }
                }
            }
            if(i < enemies.length && enemies[i].y > height) enemies.splice(i, 1);
        }
    }

    function drawPlayerPlane(ctx, x, y) {
        ctx.save(); ctx.translate(x, y);
        let tilt = (player.x - (1-input.x)*width) * 0.05;
        ctx.rotate(Math.max(-0.4, Math.min(0.4, tilt)));
        ctx.fillStyle = input.isPinching ? "#ffe" : "#eee";
        ctx.beginPath(); ctx.moveTo(0, -40); ctx.lineTo(-15, 10); ctx.lineTo(-35, 20); ctx.lineTo(0, 35); ctx.lineTo(35, 20); ctx.lineTo(15, 10); ctx.fill();
        ctx.fillStyle = input.isPinching ? "#ffaa00" : "#00f3ff"; ctx.beginPath(); ctx.arc(0, 0, 5, 0, Math.PI*2); ctx.fill();
        ctx.fillStyle = input.isPinching ? "rgba(255, 170, 0, 0.6)" : "rgba(0, 243, 255, 0.6)"; 
        ctx.beginPath(); ctx.moveTo(-5, 35); ctx.lineTo(0, 60 + Math.random()*20); ctx.lineTo(5, 35); ctx.fill();
        ctx.restore();
    }

    function drawEnemyPlane(ctx, x, y, hue) {
        ctx.save(); ctx.translate(x, y); ctx.rotate(Math.PI); 
        let color = `hsl(${hue}, 100%, 50%)`;
        ctx.shadowBlur = 15; ctx.shadowColor = color;
        ctx.fillStyle = "#111"; ctx.strokeStyle = color; ctx.lineWidth = 2;
        ctx.beginPath(); ctx.moveTo(0, -40); ctx.lineTo(-15, 10); ctx.lineTo(-35, 20); ctx.lineTo(0, 35); ctx.lineTo(35, 20); ctx.lineTo(15, 10); ctx.closePath(); ctx.fill(); ctx.stroke();
        ctx.fillStyle = color; ctx.beginPath(); ctx.arc(0, 0, 4, 0, Math.PI*2); ctx.fill();
        ctx.globalCompositeOperation = "lighter"; ctx.fillStyle = color; ctx.globalAlpha = 0.8; ctx.beginPath(); ctx.moveTo(-5, 35); ctx.lineTo(0, 55 + Math.random()*15); ctx.lineTo(5, 35); ctx.fill();
        ctx.restore();
    }

    function spawnExplosion(x, y, color, count) {
        for(let i=0; i<count; i++) particles.push({ x: x, y: y, vx: (Math.random()-0.5)*10, vy: (Math.random()-0.5)*10, life: 1.0, color: color });
    }

    // --- MediaPipe & Camera Logic ---
    let isProcessingFrame = false;
    let lastSendTime = 0;
    const DETECT_INTERVAL = 40; 
    let currentFacingMode = 'user'; // 默认为前置摄像头
    let activeCamera = null;

    // 手势辅助函数
    function isHandOpen(landmarks) {
        const wrist = landmarks[0];
        const tips = [4, 8, 12, 16, 20];
        const pips = [3, 6, 10, 14, 17];
        let openFingers = 0;
        for(let i=0; i<5; i++) {
            let dTip = Math.hypot(landmarks[tips[i]].x - wrist.x, landmarks[tips[i]].y - wrist.y);
            let dPip = Math.hypot(landmarks[pips[i]].x - wrist.x, landmarks[pips[i]].y - wrist.y);
            if(dTip > dPip) openFingers++;
        }
        return openFingers === 5; 
    }

    function calculatePinch(landmarks) {
        const thumbTip = landmarks[4];
        const indexTip = landmarks[8];
        return Math.hypot(thumbTip.x - indexTip.x, thumbTip.y - indexTip.y) < 0.05; 
    }

    function onResults(results) {
        isProcessingFrame = false;
        detectFrameCount++; 

        const w = 240, h = 180;
        hudCtx.save();
        hudCtx.clearRect(0, 0, w, h);
        if(results.image) hudCtx.drawImage(results.image, 0, 0, w, h);
        
        hudCtx.fillStyle = "rgba(0, 20, 30, 0.7)"; hudCtx.fillRect(0, 0, w, h);
        hudCtx.strokeStyle = "rgba(0, 243, 255, 0.1)"; hudCtx.lineWidth = 1;
        hudCtx.beginPath(); hudCtx.moveTo(w/2, 0); hudCtx.lineTo(w/2, h); hudCtx.moveTo(0, h/2); hudCtx.lineTo(w, h/2); hudCtx.stroke();

        if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
            loadingEl.style.display = 'none';
            // 显示开始屏幕 (仅首次)
            if(!isGameRunning && startScreen.style.display === 'none') {
                startScreen.style.display = 'flex';
                camHintEl.innerText = "摄像头就绪";
            }

            lostTrackingFrames = 0;
            trackingStatusEl.innerText = "LOCKED"; trackingStatusEl.style.color = "#00f3ff";

            const landmarks = results.multiHandLandmarks[0];
            const centerX = (landmarks[0].x + landmarks[5].x + landmarks[17].x) / 3 * w;
            const centerY = (landmarks[0].y + landmarks[5].y + landmarks[17].y) / 3 * h;

            // --- 核心修复：坐标映射 ---
            // 如果是前置(user)，已经是镜像的，直接使用。
            // 如果是后置(environment)，画面未镜像，但我们需要将“屏幕左边”映射为 input.x=1 (因为游戏逻辑 targetX = (1-input.x)*width)
            // 实际上为了简化，我们让 input.x 始终代表“屏幕位置从左到右 0~1”
            
            let rawX = landmarks[8].x;
            if (currentFacingMode === 'environment') {
                // 后置摄像头模式下，我们需要反转坐标以匹配人类直觉
                // 物理向左移 -> 画面物体向左移 -> X变小
                // 游戏逻辑是 (1-input.x)，意味着 input.x 越小，targetX 越大(右) -- 这反了。
                // 我们需要让 input.x 保持镜像逻辑
                input.x = 1 - rawX; 
            } else {
                input.x = rawX;
            }

            input.y = landmarks[8].y;
            input.active = true;
            input.isPinching = calculatePinch(landmarks);

            fireModeEl.innerText = input.isPinching ? "MODE: RAPID" : "MODE: AUTO";
            fireModeEl.style.color = input.isPinching ? "#ffaa00" : "#fff";

            if(isGameOver && !isRestarting) {
                if(isHandOpen(landmarks)) {
                    if(palmHoldStartTime === 0) palmHoldStartTime = Date.now();
                    let elapsed = Date.now() - palmHoldStartTime;
                    let progress = Math.min(1, elapsed / 3000); 
                    updateChargingSound(progress);
                    hudCtx.strokeStyle = "#00ff00"; hudCtx.lineWidth = 5;
                    hudCtx.beginPath(); hudCtx.arc(centerX, centerY, 25, -Math.PI/2, (-Math.PI/2) + (Math.PI*2 * progress)); hudCtx.stroke();
                    if(progress >= 1) { startRestartCountdown(); palmHoldStartTime = 0; }
                } else {
                    palmHoldStartTime = 0; stopChargingSound();
                }
            }

            hudCtx.strokeStyle = "rgba(0, 243, 255, 0.5)"; hudCtx.lineWidth = 1.5;
            const fingers = [[4, 3, 2], [8, 7, 6], [12, 11, 10], [16, 15, 14], [20, 19, 18]];
            fingers.forEach(finger => {
                hudCtx.beginPath();
                hudCtx.moveTo(landmarks[finger[0]].x * w, landmarks[finger[0]].y * h);
                hudCtx.lineTo(landmarks[finger[1]].x * w, landmarks[finger[1]].y * h);
                hudCtx.lineTo(landmarks[finger[2]].x * w, landmarks[finger[2]].y * h);
                hudCtx.lineTo(centerX, centerY);
                hudCtx.stroke();
                finger.forEach(idx => {
                    hudCtx.beginPath(); hudCtx.arc(landmarks[idx].x * w, landmarks[idx].y * h, 2, 0, Math.PI*2); hudCtx.fillStyle = "#fff"; hudCtx.fill();
                });
            });

            const tx = landmarks[8].x * w; const ty = landmarks[8].y * h;
            hudCtx.strokeStyle = isGameOver ? "#ff0055" : (input.isPinching ? "#ffaa00" : "#00f3ff"); 
            hudCtx.lineWidth = 2; hudCtx.beginPath(); hudCtx.arc(tx, ty, 15, 0, Math.PI*2);
            hudCtx.stroke();
            
        } else {
            if (lostTrackingFrames < MAX_LOST_FRAMES) {
                lostTrackingFrames++;
                trackingStatusEl.innerText = "重新连接..."; trackingStatusEl.style.color = "#ffff00";
                input.active = true;
                const tx = (currentFacingMode === 'environment' ? 1 - input.x : input.x) * w;
                const ty = input.y * h;
                hudCtx.setLineDash([5, 5]); hudCtx.strokeStyle = "rgba(0, 243, 255, 0.3)";
                hudCtx.beginPath(); hudCtx.arc(tx, ty, 15, 0, Math.PI*2); hudCtx.stroke(); hudCtx.setLineDash([]);
            } else {
                input.active = false; input.isPinching = false; palmHoldStartTime = 0; stopChargingSound();
                trackingStatusEl.innerText = "中断"; trackingStatusEl.style.color = "#ff0055";
                hudCtx.save();
                // 确保文字在不同镜像模式下都能看懂
                if(currentFacingMode === 'user') hudCtx.scale(-1, 1);
                hudCtx.fillStyle = "#ff0055"; hudCtx.font = "16px monospace";
                hudCtx.fillText("信号中断...", currentFacingMode === 'user' ? -w/2 - 40 : w/2 - 40, h/2);
                hudCtx.restore();
            }
        }
        hudCtx.restore();
    }

    const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
    hands.setOptions({ maxNumHands: 1, modelComplexity: 0, minDetectionConfidence: 0.35, minTrackingConfidence: 0.35 });
    hands.onResults(onResults);

    // --- 摄像头控制逻辑 ---
    async function startCamera(facingMode) {
        // 如果已经有运行的camera实例，尝试停止旧的流
        if (videoElement.srcObject) {
            videoElement.srcObject.getTracks().forEach(track => track.stop());
        }

        currentFacingMode = facingMode;
        
        // 更新 UI 文本
        cameraTypeText.innerText = facingMode === 'user' ? "前置" : "后置";
        
        // 设置 HUD 镜像样式：前置需要镜像，后置不需要
        hudCanvas.style.transform = facingMode === 'user' ? 'scaleX(-1)' : 'scaleX(1)';

        activeCamera = new Camera(videoElement, {
            onFrame: async () => { 
                const now = Date.now();
                if (!isProcessingFrame && (now - lastSendTime > DETECT_INTERVAL)) { 
                    isProcessingFrame = true; 
                    lastSendTime = now;
                    await hands.send({image: videoElement}); 
                } 
            },
            facingMode: facingMode, // 关键：指定摄像头
            width: 320, // 降低一点分辨率以提高移动端性能
            height: 240 
        });
        
        await activeCamera.start();
    }

    // 绑定切换按钮事件
    btnSwitchCam.addEventListener('click', (e) => {
        e.stopPropagation(); // 防止点击穿透到游戏
        e.preventDefault();
        
        // 切换模式
        const newMode = currentFacingMode === 'user' ? 'environment' : 'user';
        startCamera(newMode);
    });

    // 启动默认摄像头 (前置)
    startCamera('user');
    gameLoop();

</script>
</body>
</html>
